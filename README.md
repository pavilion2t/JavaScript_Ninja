# JavaScript_Ninja
This repo is organized to take you from an apprentice to a ninja in four parts.

## Part 1 
introduces the topic and sets the stage so that you can easily progress
through the rest: 
* Chapter 1 introduces JavaScript the language and its most important features,
while suggesting current best practices we should follow when developing applications,
including testing and performance analysis. 
* Because our exploration of JavaScript is made in the context of browsers, in
chapter 2 we’ll introduce the lifecycle of client-side web applications.

## Part 2 
focuses on one of the pillars of JavaScript: functions.We’ll study why functions
are so important in JavaScript, the different kinds of functions, as well as the nittygritty
details of defining and invoking functions. We’ll put a special focus on a new
type of function—generator functions—which are especially helpful when dealing
with asynchronous code:
* Chapter 3 begins our foray into the fundamentals of the language, starting, perhaps
to your surprise, with a thorough examination of the function as defined by
JavaScript.
* We continue this functional thread in chapter 4, by exploring the exact mechanism
of invoking functions, as well as the ins and outs of implicit function
parameters.
* Not being done with functions quite yet, in chapter 5 we take our discussion to
the next level by studying two closely related concepts: scopes and closures. A key
concept in functional programming, closures allow us to exert fine-grained
control over the scope of objects that we declare and create in our programs.
The control of these scopes is the key factor in writing code worthy of a ninja.
* We conclude our exploration of functions in chapter 6, by taking a look at a
completely new type of function (generator functions) and a new type of object
(promises) that help us deal with asynchronous values. We’ll also show you how
to combine generators and promises to achieve elegance when dealing with
asynchronous code.

## Part 3 
deals with the second pillar of JavaScript: objects. We’ll thoroughly explore
object orientation in JavaScript, and we’ll study how to guard access to objects and
how to deal with collections and regular expressions:
* Objects are finally addressed in chapter 7, where we learn exactly how
JavaScript’s slightly strange flavor of object orientation works. We’ll also introduce
a new addition to JavaScript: classes, which, deep under the hood, may not
be exactly what you expect.
* We’ll continue our exploration of objects in chapter 8, where we’ll study different
techniques for guarding access to our objects.
* In chapter 9, we’ll put a special focus on different types of collections that exist
in JavaScript; on arrays, which have been a part of JavaScript since its beginnings;
and on maps and sets, which are recent addition to JavaScript.
* Chapter 10 focuses on regular expressions, an often-overlooked feature of the
language that can do the work of scores of lines of code when used correctly.
* In chapter 11, we’ll learn different techniques for organizing our code into
modules: smaller, relatively loosely coupled segments that improve the structure
and organization of our code.

## Part 4 
wraps up by studying how JavaScript interacts with our web
pages and how events are processed by the browser. We’ll look at
an important topic, cross-browser development:
* Chapter 12 explores how we can dynamically modify our pages through DOMmanipulation
APIs, and how we can handle element attributes, properties, and
styles, as well as some important performance considerations.
* Chapter 13 discusses the importance of JavaScript’s single-threaded execution
model and the consequences this model has on the event loop. We’ll also learn
how timers and intervals work and how we can use them to improve the perceived
performance of our web applications.
* Chapter 14 concludes by examining the five key development concerns
with regard to these cross-browser issues: browser differences, bugs and
bug fixes, external code and markup, missing features, and regressions. Strategies
such as feature simulation and object detection are discussed at length to
help us deal with these cross-browser challenges.
